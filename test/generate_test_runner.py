import argparse
import pathlib
import re


SOURCE_TEMPLATE = """/***********************************************************************************/
/* WARNING:                                                                        */
/* This file is generated by a script - do not modify it or add to source control! */
/***********************************************************************************/

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>

#include "test_macros.h"

/* Test result tracking */
#define IMPL_STRINGIFY_(a) #a
#define IMPL_STRINGIFY(a) IMPL_STRINGIFY_(a)
#define IMPL_TEST_CASE_FUNCTION_NAME_PREFIX_STRING IMPL_STRINGIFY(IMPL_CASE_FUNCTION_NAME_PREFIX)

#define IMPL_dyn_arr_maybe_grow(arr)                                    \\
    do {                                                                \\
        if ((arr)->count == ((arr)->capacity - 1)) {                    \\
            assert((arr)->capacity >= 1);                               \\
            int32_t new_cap = (arr)->capacity * 2;                      \\
            void *new_arr = realloc((arr)->items, (size_t)new_cap       \\
                * sizeof(*(arr)->items));                               \\
            assert(new_arr);                                            \\
            (arr)->capacity = new_cap;                                  \\
            (arr)->items = new_arr;                                     \\
        }                                                               \\
    } while (0)

#define IMPL_dyn_arr_push(arr, item)            \\
    do {                                        \\
        IMPL_dyn_arr_maybe_grow(arr);           \\
        (arr)->items[(arr)->count++] = (item);  \\
    } while (0)

typedef struct {
    const char *expression_string;
    int32_t line;
} IMPL_Assert;

typedef struct {
    IMPL_Assert *items;
    int32_t count;
    int32_t capacity;
} IMPL_AssertList;

typedef struct {
    const char *test_case_name;
    const char *filename;
    IMPL_AssertList successful_assertions;
    IMPL_AssertList failed_assertions;
} IMPL_TestCase;

typedef struct {
    IMPL_TestCase *items;
    int32_t count;
    int32_t capacity;
} IMPL_TestCaseList;

static IMPL_TestCaseList IMPL_test_cases;

static void IMPL_push_assert(IMPL_TestCase *test_case, IMPL_AssertList *list, const char *filename,
    const char *expr_string, int32_t line)
{
    // NOTE: Assigning filename is done here because test cases structs are created when first
    // running test, at which point we don't have access to the filename of the test case
    assert(!test_case->filename || (strcmp(test_case->filename, filename) == 0));
    test_case->filename = filename;

    IMPL_Assert a = {
        .expression_string = expr_string,
        .line = line
    };

    IMPL_dyn_arr_push(list, a);
}

static IMPL_TestCase *IMPL_get_current_test_case()
{
    assert(IMPL_test_cases.count >= 1);
    IMPL_TestCase *result = &IMPL_test_cases.items[IMPL_test_cases.count - 1];

    return result;
}

static void IMPL_save_failed_assert(const char *filename, const char *expr_string, int32_t line)
{
    IMPL_TestCase *current_case = IMPL_get_current_test_case();
    IMPL_push_assert(current_case, &current_case->failed_assertions, filename, expr_string, line);
}

static void IMPL_save_passed_assert(const char *filename, const char *expr_string, int32_t line)
{
    IMPL_TestCase *current_case = IMPL_get_current_test_case();
    IMPL_push_assert(current_case, &current_case->successful_assertions, filename, expr_string, line);
}

/* Included test files go here */
{INSERT_INCLUDE_DIRECTIVES}

/* Test runner code */
#define INITIAL_ASSERT_LIST_CAPACITY 64
#define INITIAL_TEST_CASE_LIST_CAPACITY 32

#define COLOR_WHITE  "\\x1b[37m"
#define COLOR_GREEN  "\\x1b[32m"
#define COLOR_RED    "\\x1b[31m"
#define COLOR_YELLOW "\\x1b[33m"
#define COLOR_CYAN   "\\x1b[36m"
#define COLOR_NORMAL  "\\x1b[0m"
#define TEXT_NORMAL  "\\x1b[22m"
#define TEXT_BOLD    "\\x1b[1m"

#define SUMMARY_TITLE_STYLE
#define SUMMARY_PASS_STYLE COLOR_GREEN
#define SUMMARY_FAIL_STYLE COLOR_RED TEXT_BOLD
#define FILENAME_STYLE
#define EXPR_STYLE COLOR_CYAN

#define BAR_WIDTH 50

#define print_summary_string(title, total, passed, failed)      \\
    printf(                                                     \\
        SUMMARY_TITLE_STYLE title ": " COLOR_NORMAL "%d"" | "    \\
        SUMMARY_PASS_STYLE "%d passed"COLOR_NORMAL" | "          \\
        SUMMARY_FAIL_STYLE"%d failed\\n"COLOR_NORMAL              \\
        TEXT_NORMAL,                                            \\
        total, passed, failed)

#define RUN_TEST(name)                          \\
    do {                                        \\
        push_new_test_case(#name);              \\
        IMPL_GET_CASE_FUNCTION_NAME(name)();    \\
    } while (0)

typedef struct {
    int32_t failed_assert_count;
    int32_t passed_assert_count;
    int32_t passed_test_case_count;
    int32_t failed_test_case_count;
} TestSummary;

static IMPL_AssertList create_result_list()
{
    IMPL_AssertList result = {0};
    result.capacity = INITIAL_ASSERT_LIST_CAPACITY;
    result.items = calloc((size_t)result.capacity, sizeof(*result.items));

    return result;
}

static IMPL_TestCaseList create_test_case_list()
{
    IMPL_TestCaseList result = {0};
    result.capacity = INITIAL_TEST_CASE_LIST_CAPACITY;
    result.items = malloc((size_t)result.capacity * sizeof(*result.items));

    return result;
}

static void push_new_test_case(const char *test_case_name)
{
    IMPL_TestCase new_test_case = {
        .test_case_name = test_case_name,
        .failed_assertions = create_result_list(),
        .successful_assertions = create_result_list()
    };

    IMPL_dyn_arr_push(&IMPL_test_cases, new_test_case);
}

static TestSummary get_test_summary()
{
    TestSummary result = {0};

    for (int32_t i = 0; i < IMPL_test_cases.count; ++i) {
        IMPL_TestCase *test_case = &IMPL_test_cases.items[i];

        int32_t failed = test_case->failed_assertions.count;
        int32_t passed = test_case->successful_assertions.count;
        result.failed_assert_count += failed;
        result.passed_assert_count += passed;

        if (failed == 0) {
            ++result.passed_test_case_count;
        } else {
            ++result.failed_test_case_count;
        }
    }

    return result;
}

static void repeat_char(char c, const char *color, int32_t width, int32_t newline)
{
    printf("%s", color);

    for (int32_t i = 0; i < width; ++i) {
        printf("%c", c);
    }

    printf(COLOR_NORMAL);

    if (newline) {
        printf("\\n");
    }
}

static void print_assert_failures()
{
    for (int32_t i = 0; i < IMPL_test_cases.count; ++i) {
        IMPL_TestCase *curr_case = &IMPL_test_cases.items[i];

        if (curr_case->failed_assertions.count > 0) {
            printf("\\n");
            repeat_char('-', COLOR_NORMAL, BAR_WIDTH, 1);
            printf("%s (%s)\\n", curr_case->test_case_name, curr_case->filename);
            repeat_char('-', COLOR_NORMAL, BAR_WIDTH, 1);
        }

        for (int32_t j = 0; j < curr_case->failed_assertions.count; ++j) {
            IMPL_Assert *a = &curr_case->failed_assertions.items[j];

            printf("\\n"SUMMARY_FAIL_STYLE"TEST FAILED:"COLOR_NORMAL"\\n");
            printf(FILENAME_STYLE"%s:%d:"COLOR_NORMAL"\\n", curr_case->filename, a->line);
            printf(EXPR_STYLE"    %s"COLOR_NORMAL"\\n\\n", a->expression_string);

            repeat_char('.', COLOR_NORMAL, BAR_WIDTH, 1);
        }
    }
}

static void print_progress_bar(int32_t a, int32_t b)
{
    float ratio = (float)a / (float)b;

    int32_t green_width = (int32_t)((float)BAR_WIDTH * ratio);
    int32_t red_width = BAR_WIDTH - green_width;
    repeat_char('=', COLOR_GREEN, green_width, 0);
    repeat_char('=', COLOR_RED, red_width, 1);
}

static void print_summary()
{
    TestSummary summary = get_test_summary();
    int32_t assert_count = summary.failed_assert_count + summary.passed_assert_count;
    int32_t test_case_count = summary.failed_test_case_count + summary.passed_test_case_count;

    printf("\\n");
    repeat_char('~', COLOR_NORMAL, BAR_WIDTH, 1);

    print_assert_failures();

    printf("\\n");

    if (assert_count == 0) {
        printf(COLOR_YELLOW"No tests ran.\\n"COLOR_NORMAL);
    } else if (summary.failed_test_case_count == 0) {
        printf(
            COLOR_GREEN"All tests passed (%d assertion%s in %d test case%s)\\n"COLOR_NORMAL,
            assert_count,
            assert_count > 1 ? "s" : "",
            IMPL_test_cases.count,
            IMPL_test_cases.count > 1 ? "s" : ""
        );
    } else {
        print_progress_bar(summary.passed_test_case_count, test_case_count);

        print_summary_string(
            "Test cases",
            IMPL_test_cases.count,
            summary.passed_test_case_count,
            summary.failed_test_case_count
        );

        print_summary_string(
            "Assertions",
            assert_count,
            summary.passed_assert_count,
            summary.failed_assert_count
        );

        print_progress_bar(summary.passed_assert_count, assert_count);
    }

    printf("\\n");
    repeat_char('~', COLOR_NORMAL, BAR_WIDTH, 1);
}

int main()
{
    IMPL_test_cases = create_test_case_list();

    /* Calls to test case functions go here */
    {INSERT_TEST_CASE_CALLS}

    print_summary();

    // TODO: return non-zero if failed?
    return 0;
}
"""

COLOR_RED   = '\x1b[31m'
COLOR_NORMAL = '\x1b[0m'

def gather_test_cases_in_file(file_contents):
    matches = re.findall(r'TEST_CASE\((.*)\)', file_contents)
    return matches

def gather_test_cases(filenames):
    cases = []
    encountered_case_names = set()
    errors = []

    for filename in filenames:
        try:
            with open(filename) as f:
                cases_in_file = gather_test_cases_in_file(f.read())
                cases += cases_in_file

                for case in cases_in_file:
                    if case in encountered_case_names:
                        print(f'{COLOR_RED}error: Multiple definition of test case \'{case}\'. Stopping.{COLOR_NORMAL}');
                        exit(1)
                    elif len(case) == 0:
                        print(f'{COLOR_RED}error: Test case name can not be empty. Stopping.{COLOR_NORMAL}');
                        exit(1)

                    encountered_case_names.add(case)
        except IOError:
            print(f'{COLOR_RED}error: Could not open file \'{filename}\'. Stopping.{COLOR_NORMAL}')
            exit(1)
    return cases

def create_test_runner_source(files, test_cases, output_dir):
    include_directives = ''

    for f in files:
        relative = pathlib.Path(f).relative_to(output_dir)
        include_directives += f'#include "{relative}"\n'

    test_case_calls = ''

    for case in test_cases:
        test_case_calls += f'RUN_TEST({case});\n    '

    # TODO: find a better way to replace strings in this template
    result = SOURCE_TEMPLATE                                    \
    .replace('{INSERT_INCLUDE_DIRECTIVES}', include_directives) \
    .replace('{INSERT_TEST_CASE_CALLS}',    test_case_calls)

    return result

def main():
    parser = argparse.ArgumentParser(prog='generate_test_runner')
    parser.add_argument('filenames', nargs='+')
    parser.add_argument('-o', '--output', required=True)

    args = parser.parse_args()

    input_files = args.filenames
    output_path = pathlib.Path(args.output)
    output_dir = output_path.parent

    test_cases_to_run = gather_test_cases(input_files)

    source_string = create_test_runner_source(input_files, test_cases_to_run, output_dir)

    with open(output_path, 'w') as f:
        f.write(source_string)


if __name__ == '__main__':
    main()
